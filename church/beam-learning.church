(define transform-types (list compressions))

;;;searches through transformations of the sexpr (uniform-draw (list [observed data here])) , returns a thunk evaluates a uniforml draws over compressed forms of each observation, here data is a list of factor graphs
(define (learn-model data beam-size depth)
  (let* ([initial-sexpr (make-initial-sexpr data)]
         [learned-sexpr (beam-learn data initial-sexpr beam-size depth)]
         [learned-sexpr (if (null? learned-sexpr) initial-sexpr learned-sexpr)]
         [model (lambda () (lazy-list->all-list ((eval learned-sexpr))))])
    (pretty-print (list "compressed-program:" learned-sexpr "size: " (size learned-sexpr)))    
    model))

;;;turns each image into factor-graphs then turns factor-graphs into programs then wraps that in a uniform draw
;;make-initial-sexpr :: images => scheme-program
(define (make-initial-sexpr images)
  (let* ([factor-graphs (map image->factor-graph images)]
         [literal-sexprs (map python-format->scheme-program factor-graphs)])
    (list 'lambda '() (list (list 'uniform-draw (pair 'list literal-sexprs))))))

;;;returns an sexpr
(define (beam-learn data sexpr beam-size depth)
  (let* ([top-transformations 
          (sort-by-posterior
           data (unique-programs
            (beam-learn-search-transformations data (make-program '() sexpr) data beam-size depth)))])
    (if (null? top-transformations)
        sexpr
        (program->sexpr (first top-transformations)))))


(define (beam-learn-search-transformations data program beam-size depth)
  (depth-iterated-transformations (lambda (progs) (best-n data (unique-programs progs) beam-size)) program depth))

(define (my-iterated-transformations cfilter program)
  (let* ([compressed-programs (cfilter (compressions program))])
    (append compressed-programs
            (apply append (map (lambda (prog) (my-iterated-transformations cfilter prog)) compressed-programs)))))

;;depth-iterated-transformations is only for testing purposes to check if my-iterated-transformations is correct
(define (depth-iterated-transformations cfilter program depth)
  (let* ([transformed-programs (if (= depth 0) '() (concatenate (map (lambda (transform-type) (cfilter (transform-type program #t))) transform-types)))])
    (delete '()  (append transformed-programs
             (apply append (map (lambda (prog) (depth-iterated-transformations cfilter prog (- depth 1))) transformed-programs))))))

(define (best-n data programs n)
  (max-take (sort-by-posterior data programs) n))


(define (sort-by-posterior data programs)
  (let* ([log-priors (map log-prior programs)]
         [log-likelihoods (map (lambda (prog) (log-likelihood prog data 10)) programs)]
         [posteriors (map + log-priors log-likelihoods)] ;;log-prior and log-likelihood are log-probabilities
         [programs-with-posteriors (zip programs posteriors)]
         [posteriors< (lambda (a b) (< (second a) (second b)))])
    (map first (my-list-sort posteriors< programs-with-posteriors))))

;;how do you find normalized values?
(define (log-prior program)
  (- (size (program->sexpr program))))

;;;list sorting via something like quicksort
(define (my-list-sort compare lst)
  (if (null? lst)
      '()
      (let* ([pivot (first lst)]
             [lst (rest lst)]
             [lessthan+greaterthan (my-partition compare pivot lst)])
        (append (my-list-sort compare (first lessthan+greaterthan)) (pair pivot (my-list-sort compare (second lessthan+greaterthan)))))))

;;;returns a two item list where the first item is a list of all the elements where (compare item pivot) is true and the second is a list where the values are false
(define (my-partition compare pivot lst)
  (if (null? lst)
      (list '() '())
      (let* ([comparestrue+comparesfalse (my-partition compare pivot (rest lst))]
             [comparestrue (first comparestrue+comparesfalse)]
             [comparesfalse (second comparestrue+comparesfalse)]
             [current-item (first lst)])
        (if (compare current-item pivot)
            (list (pair current-item comparestrue) comparesfalse)
            (list comparestrue (pair current-item comparesfalse))))))
         

(define (combine-size-score sizes scores size-weight score-weight)
  (map +
       (map (lambda (x) (* x size-weight)) sizes)
       (map (lambda (x) (* (exp x) (- score-weight))) scores)))

(define (compose f g)
  (lambda (x) (f (g x))))


;;;given a topology for a factor graph generate factor graphs with that form (in python format)
(define generate-factor-graphs_top
  (lambda (prog-sexpr topology popsize)
    (let ([prog (eval (program->sexpr prog-sexpr))])
      (let* ([lazified-topology (list->lazy-list topology)]
             (samples (smc-core (map list (iota (+ 1 (lazy-list-size  lazified-topology)))) popsize 20
                                (lambda (depth) (lambda () (let ((s (prog)))
                                                             (pair (lazy-topology-equal? s lazified-topology depth)
                                                                   (lambda () (first (lazy-list->list s depth)))))))))
             [factor-graphs (map (compose lazy-list->all-list mcmc-state->query-value) samples)])
        factor-graphs))))

;;;computes the likelihood of the data given the prog, should never receive '() as a prog
;;here we assume prog is a thunk we can apply, should be much faster since we don't have to eval
;;computes p(fg_top|compression) only takes into account the topology of a factor-graph
(define score-fg-top_program 
   (lambda (prog-sexpr topology popsize)
     (let ([prog (eval (program->sexpr prog-sexpr))])
       (let* ([lazified-topology (list->lazy-list topology)]
              (samples (smc-core (map list (iota (+ 1 (lazy-list-size  lazified-topology)))) popsize 20
                                 (lambda (depth) (lambda () (let ((s (prog)))
                                                              (pair (lazy-topology-equal? s lazified-topology depth)
                                                                    (lambda () (first (lazy-list->list s depth)))))))))
              ;;remove duplicates in order to do selective model averaging:
              ;;find symbol for repeat function and delete (temporary fix)
              (repeat-symbol (find-repeat-symbol samples))
              [db (pretty-print (list "before selection" (map mcmc-state->query-value samples)))]
              (samples (fold (lambda (s a) (if (member (mcmc-state->addrval s repeat-symbol) (map (lambda (x) (mcmc-state->addrval x repeat-symbol)) a)) a (pair s a))) '() samples))
              [db (pretty-print (list "after selection" (length samples)))]
              (scores (map mcmc-state->score samples))
              (score (if (null? scores)
                         -inf.0
                         (apply log-sum-exp scores))))
                                        ;(- (apply log-sum-exp scores) (log (length scores))))))
         score))))


;;temporary fix of addresses for same xrps not being the same; this is due to the way smc-core creates the particles
;;the fix works because factor graph programs only contain node expressions and function definition (no uses of repeat)
;;a more permanent fix would be to use the rejection-initializer that can be passed an explicit starting address
;;assumes argument is a list and there is only one address that repeats (if at all) across all xrps

;;need to address the fact that the address containing the repeated address only once will not delete 
(define (mcmc-state->addrval s repeated)
  (map (lambda (d)
         (pair (delete repeated (xrp-draw-address (rest d))) (xrp-draw-value (rest d)))) (mcmc-state->xrp-draws s)))


(define (find-repeat-symbol states)
  (if (null? states)
      '()
      (let ([repeat-symbol (find-repeat-symbol-in-state (map rest (mcmc-state->xrp-draws (first states))))])
        (if (null? repeat-symbol)
            (find-repeat-symbol (rest states))
            repeat-symbol))))

(define (find-repeat-symbol-in-state state-xrp-draws)
  (if (null? state-xrp-draws)
      '()
      (let* ([addr (xrp-draw-address (first state-xrp-draws))]
             [repeat-symbol (find-repeated addr)])
        (if (null? repeat-symbol)
            (find-repeat-symbol-in-state (rest state-xrp-draws))
            repeat-symbol))))

(define (find-repeated addr-lst)
  (if (more-than-one? addr-lst)
      (let ([current (first addr-lst)])
        (if (and (equal? current (second addr-lst)) (not (null? current)))
            current
            (find-repeated (rest addr-lst))))
      '()))

;;assumes argument is a list, move this to util.ss
(define (more-than-one? lst)
  (if (null? lst)
      #f
      (if (null? (rest lst))
              #f
              #t)))



;;;estimates p(images|program) ~= \frac{1}{R}\sum_{fg_r ~ p(fg|program)}p(images|fg) where R is the nubmer of samples
;;;this is the likelihood 
(define (scoring-fg-image prog sample-size)
  (let* ([fg-sampler (eval prog)]
         [fg-samples (repeat sample-size (lambda () (lazy-list->all-list (fg-sampler))))]
         [likelihoods (map fg->img-score fg-samples)])
    (/ (apply + likelihoods) sample-size)))  ;;;if likelihoods are probabilities and not log probabilities


;;;estimates p(images|program) ~= \frac{1}{R}\sum_{fg_r ~ p(fg|fg_top)}p(images|fg)p(fg_top|prog) where R is the number of samples
;;;this is an importance sampler where the target distribution generates factor graphs based on topology extracted from the images
;;assumes all factor-graphs from imags->factor-graphs have the same topology
;; '_' can be read as given e.g. fg-top_prog is fg-top given prog 
(define (log-likelihood data prog sample-size)
  (let* ([fg-top (eval (python-format->scheme-program (image->factor-graph (first data))))]
         [fg-top_prog-score (score-fg-top_program prog fg-top sample-size)] ;;number of particles doesn't have to be sample-size
         [factor-graphs (generate-factor-graphs_top prog fg-top sample-size)] ;;these might need to be converted into python-format
         [true-sample-size (length factor-graphs)]
         [image_fg-scores (map (compose fg->img-score scheme-format->python-format) factor-graphs)])
    (/ (* (apply + image_fg-scores) fg-top_prog-score) true-sample-size)))

